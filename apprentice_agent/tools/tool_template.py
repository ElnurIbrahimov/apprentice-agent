"""Base template for dynamically generated tools.

This template provides the structure for custom tools created by ToolBuilderTool.
Generated tools follow this pattern with custom implementations.
"""

# Standard safe imports allowed in generated tools
SAFE_IMPORTS = """
import json
import re
from datetime import datetime, timedelta
from typing import Any, Optional
import math
import random
import hashlib
import base64
from urllib.parse import urlencode, quote, unquote
"""

# Imports that require network access (optional)
NETWORK_IMPORTS = """
import requests
"""

# Blocked patterns that should never appear in generated code
BLOCKED_PATTERNS = [
    r'\bos\.system\b',
    r'\bsubprocess\b',
    r'\beval\s*\(',
    r'\bexec\s*\(',
    r'\b__import__\s*\(',
    r'\bcompile\s*\(',
    r'\bgetattr\s*\(.+,\s*[\'"]__',  # getattr with dunder access
    r'\bsetattr\s*\(.+,\s*[\'"]__',  # setattr with dunder access
    r'\bdelattr\s*\(',
    r'\bglobals\s*\(\)',
    r'\blocals\s*\(\)',
    r'\bvars\s*\(\)',
    r'\b__builtins__\b',
    r'\b__class__\b',
    r'\b__bases__\b',
    r'\b__subclasses__\b',
    r'\b__mro__\b',
    r'\bopen\s*\([^)]*["\'][wa]',  # open() with write/append mode
    r'\bctypes\b',
    r'\bsocket\b',
    r'\bshutil\.rmtree\b',
    r'\bos\.remove\b',
    r'\bos\.unlink\b',
    r'\bos\.rmdir\b',
    r'\bpickle\b',
    r'\bmarshall\b',
]

# Template for generated tool class
TOOL_CLASS_TEMPLATE = '''"""Auto-generated custom tool: {name}

Description: {description}
Created: {created_at}
Status: {status}

WARNING: This file was auto-generated by ToolBuilderTool.
Do not edit manually unless you know what you're doing.
"""

import json
import re
from datetime import datetime, timedelta
from typing import Any, Optional
import math
import random
import hashlib
import base64
from urllib.parse import urlencode, quote, unquote

{extra_imports}

class {class_name}:
    """{description}"""

    def __init__(self):
        self.name = "{name}"
        self.description = "{description}"

{methods}

    def execute(self, action: str) -> dict:
        """Execute an action on this tool.

        Args:
            action: The action string to parse and execute

        Returns:
            Result dictionary with success status and data
        """
        action_lower = action.lower()

{execute_logic}

        return {{"success": False, "error": f"Unknown action: {{action}}"}}
'''

# Template for individual method
METHOD_TEMPLATE = '''    def {method_name}(self{params_with_types}) -> dict:
        """{description}

        Args:
{param_docs}

        Returns:
            Result dictionary with success status and data
        """
        try:
{method_body}
        except Exception as e:
            return {{"success": False, "error": str(e)}}
'''

# Template for execute logic dispatch
EXECUTE_DISPATCH_TEMPLATE = '''        if "{method_name}" in action_lower:
            {param_extraction}
            return self.{method_name}({param_call})
'''

# Template for test file
TEST_TEMPLATE = '''"""Auto-generated tests for custom tool: {name}

Created: {created_at}
"""

import sys
from pathlib import Path

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from apprentice_agent.tools.custom.{module_name} import {class_name}


def test_{name}_instantiation():
    """Test that the tool can be instantiated."""
    tool = {class_name}()
    assert tool.name == "{name}"
    assert tool.description is not None
    print(f"[PASS] {class_name} instantiation")


def test_{name}_execute_unknown():
    """Test that unknown actions return error."""
    tool = {class_name}()
    result = tool.execute("unknown_action_xyz")
    assert result.get("success") == False
    assert "error" in result
    print(f"[PASS] {class_name} handles unknown action")


{method_tests}


def run_all_tests():
    """Run all tests and return results."""
    tests = [
        test_{name}_instantiation,
        test_{name}_execute_unknown,
{test_calls}
    ]

    passed = 0
    failed = 0
    errors = []

    for test in tests:
        try:
            test()
            passed += 1
        except AssertionError as e:
            failed += 1
            errors.append(f"{{test.__name__}}: AssertionError - {{e}}")
        except Exception as e:
            failed += 1
            errors.append(f"{{test.__name__}}: {{type(e).__name__}} - {{e}}")

    return {{
        "passed": passed,
        "failed": failed,
        "total": len(tests),
        "errors": errors,
        "success": failed == 0
    }}


if __name__ == "__main__":
    results = run_all_tests()
    print(f"\\nResults: {{results['passed']}}/{{results['total']}} passed")
    if results["errors"]:
        print("Errors:")
        for err in results["errors"]:
            print(f"  - {{err}}")
    sys.exit(0 if results["success"] else 1)
'''

# Template for individual method test
METHOD_TEST_TEMPLATE = '''def test_{name}_{method_name}():
    """Test {method_name} method."""
    tool = {class_name}()
    # Basic test - method should exist and be callable
    assert hasattr(tool, "{method_name}")
    assert callable(getattr(tool, "{method_name}"))
    print(f"[PASS] {class_name}.{method_name} exists and is callable")
'''
